<!DOCTYPE html>
<html>
<head>
  <title>OptionsScreen</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: Arial, sans-serif; margin: 18px; }
    form { display: grid; grid-template-columns: repeat(auto-fit,minmax(160px,1fr)); gap: 10px; align-items: end; }
    label { display: grid; gap: 6px; font-size: 14px; }
    input, select, button { padding: 8px; font-size: 14px; }
    table { border-collapse: collapse; width: 100%; margin-top: 16px; }
    th, td { border: 1px solid #ddd; padding: 6px; text-align: center; font-size: 13px; }
    th { background: #f3f3f3; }
    tr.top { background: #f6fff4; font-weight: 600; }
    #results { margin-top: 16px; }
    #msg { margin-top: 10px; color: #b00; font-weight: 600; }
    .muted { color:#666; font-size:12px; }
  </style>
</head>
<body>
  <h2>Sell Option Screener</h2>

  <form id="optionForm">
    <label>Ticker
      <input type="text" id="ticker" placeholder="e.g. AAPL" required />
    </label>
    <label>Type
      <select id="optionType">
        <option value="put">Put</option>
        <option value="call">Call</option>
      </select>
    </label>
    <label>Strike
      <select id="strike" required>
        <option value="">-- enter ticker first --</option>
      </select>
    </label>
    <button type="submit">Search</button>
  </form>

  <div id="msg"></div>
  <div id="results"></div>
  <div class="muted">Note: Quotes may be delayed; ROI assumes cash-secured and expiry worthless.</div>

<script>
const PROXY = "https://optionsscreen.onrender.com";

const tickerInput = document.getElementById("ticker");
const optionTypeSel = document.getElementById("optionType");
const strikeSelect = document.getElementById("strike");
const msgEl = document.getElementById("msg");
const resultsEl = document.getElementById("results");
let tickerInputTimer;

const strikeCache = new Map();
const STRIKE_CACHE_TTL = 60 * 1000;
const STRIKE_COOLDOWN_MS = 30 * 1000;

function isThrottledError(err) {
  if (!err) return false;
  const status = err.status;
  const numericStatus = Number(status);
  if (Number.isFinite(numericStatus) && numericStatus === 429) {
    return true;
  }
  const message = typeof err.message === "string" ? err.message : (typeof err === "string" ? err : "");
  return message.includes("Proxy HTTP 429");
}

function sanitizeTickerValue({ updateField = true } = {}) {
  const value = tickerInput.value.toUpperCase().trim();
  if (updateField) {
    tickerInput.value = value;
  }
  return value;
}

function resetStrikeSelect() {
  strikeSelect.innerHTML = "<option value=\"\">-- enter ticker first --</option>";
}

function fetchStrikesForCurrentTicker({ updateField = true } = {}) {
  const ticker = sanitizeTickerValue({ updateField });
  if (!ticker) {
    resetStrikeSelect();
    return Promise.resolve();
  }
  return populateStrikes(ticker, optionTypeSel.value);
}

// --- helpers ---
function ensureResult(data) {
  if (!data || !data.optionChain || !Array.isArray(data.optionChain.result) || data.optionChain.result.length === 0) {
    const desc = (data && data.error && (data.error.description || data.error)) ? String(data.error.description || data.error) : "No option chain available for this ticker.";
    throw new Error(desc);
  }
  return data.optionChain.result[0];
}

async function fetchChain(ticker, date=null) {
  const t = (ticker || "").toUpperCase().trim();
  const url = `${PROXY}/options?ticker=${encodeURIComponent(t)}${date ? `&date=${encodeURIComponent(date)}` : ""}`;
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) {
    const err = new Error(`Proxy HTTP ${res.status}`);
    err.status = res.status;
    throw err;
  }
  const data = await res.json().catch(() => { throw new Error("Proxy returned non-JSON"); });
  return ensureResult(data);
}

// --- populate strikes (from nearest expiry; fast & sufficient) ---
async function populateStrikes(ticker, type) {
  const key = `${String(ticker).toUpperCase().trim()}|${type}`;
  const now = Date.now();
  const cached = strikeCache.get(key);
  const hasFreshCache = cached && Array.isArray(cached.strikes) && cached.strikes.length && (now - cached.timestamp) < STRIKE_CACHE_TTL;

  if (hasFreshCache) {
    applyStrikeOptions(cached.strikes);
    msgEl.textContent = "";
    return;
  }

  if (cached && cached.failureTimestamp && (now - cached.failureTimestamp) < STRIKE_COOLDOWN_MS) {
    if (Array.isArray(cached.strikes) && cached.strikes.length) {
      applyStrikeOptions(cached.strikes);
    } else {
      strikeSelect.innerHTML = "<option value=''>Please wait…</option>";
    }
    msgEl.textContent = "Too many requests, please wait…";
    return;
  }

  msgEl.textContent = "";
  strikeSelect.innerHTML = "<option>Loading…</option>";

  const entry = cached || {};
  if (!cached) {
    strikeCache.set(key, entry);
  }

  if (!entry.promise) {
    entry.promise = (async () => {
      try {
        const base = await fetchChain(ticker);
        const firstSet = (base.options && base.options[0]) ? base.options[0] : null;
        if (!firstSet) throw new Error("No options payload present.");
        const contracts = type === "put" ? (firstSet.puts || []) : (firstSet.calls || []);
        const strikes = [...new Set(contracts.map(c => c.strike))].sort((a,b)=>a-b);

        if (!strikes.length) throw new Error("No strikes found for nearest expiry.");

        entry.strikes = strikes;
        entry.timestamp = Date.now();
        entry.failureTimestamp = undefined;
        return strikes;
      } catch (err) {
        if (isThrottledError(err)) {
          entry.failureTimestamp = Date.now();
          const friendly = new Error("Too many requests, please wait…");
          friendly.status = 429;
          friendly.originalError = err;
          throw friendly;
        }
        throw err;
      } finally {
        delete entry.promise;
      }
    })();
  }

  try {
    const strikes = await entry.promise;
    applyStrikeOptions(strikes);
    msgEl.textContent = "";
  } catch (err) {
    if (Array.isArray(entry.strikes) && entry.strikes.length) {
      applyStrikeOptions(entry.strikes);
    } else {
      strikeSelect.innerHTML = "<option value=''>Error</option>";
    }

    if (isThrottledError(err)) {
      const fallback = "Too many requests, please wait…";
      const text = (err && typeof err.message === "string" && err.message.trim()) ? err.message : fallback;
      msgEl.textContent = text;
    } else {
      const detail = (err && err.message) ? err.message : "Unknown error";
      msgEl.textContent = "Strike load error: " + detail;
    }
  }
}

function applyStrikeOptions(strikes) {
  strikeSelect.innerHTML = "";
  strikes.forEach(s => {
    const opt = document.createElement("option");
    opt.value = s;
    opt.textContent = s;
    strikeSelect.appendChild(opt);
  });
}

// --- compute metrics across ALL expiries ---
function computeRow(match, expEpoch, strike, type) {
  const now = new Date();
  const exp = new Date(expEpoch * 1000);
  const days = Math.max(1, Math.round((exp - now) / (1000*60*60*24))); // guard
  const bid = Number(match.bid ?? 0), ask = Number(match.ask ?? 0), last = Number(match.lastPrice ?? 0);
  const mid = (bid > 0 && ask > 0) ? (bid + ask)/2 : (last > 0 ? last : 0);
  if (mid <= 0) return null;

  const collateral = strike * 100;
  const premium = mid * 100;
  const yExp = premium / collateral;
  const ann = yExp * (365 / days);
  const daily = yExp / days;
  const breakeven = type === "put" ? (strike - mid) : (strike + mid);

  return {
    expiry: exp.toISOString().split("T")[0],
    days,
    strike,
    mid: mid.toFixed(2),
    premium: premium.toFixed(2),
    collateral: collateral.toFixed(2),
    yield: (yExp * 100).toFixed(2),
    annROI: (ann * 100).toFixed(2),
    daily: (daily * 100).toFixed(4),
    breakeven: breakeven.toFixed(2),
    IV: (Number(match.impliedVolatility ?? 0) * 100).toFixed(2),
    OI: match.openInterest ?? "",
    Vol: match.volume ?? ""
  };
}

async function gatherAllRows(ticker, strike, type) {
  const base = await fetchChain(ticker);
  const dates = Array.isArray(base.expirationDates) ? base.expirationDates : [];
  if (!dates.length) throw new Error("No expiration dates available.");

  const rows = [];
  // Limit to avoid hammering (fetch first 20 expiries max)
  for (const d of dates.slice(0, 20)) {
    try {
      const set = await fetchChain(ticker, d);
      const opt = (set.options && set.options[0]) ? set.options[0] : null;
      if (!opt) continue;
      const list = type === "put" ? (opt.puts || []) : (opt.calls || []);
      const match = list.find(c => Math.abs(Number(c.strike) - strike) < 1e-6);
      if (!match) continue;
      const row = computeRow(match, opt.expirationDate || d, strike, type);
      if (row) rows.push(row);
    } catch (_) {
      /* skip bad one */
    }
  }
  return rows.sort((a,b)=>parseFloat(b.annROI) - parseFloat(a.annROI));
}

// --- UI wiring ---
tickerInput.addEventListener("input", () => {
  clearTimeout(tickerInputTimer);
  tickerInputTimer = setTimeout(() => {
    fetchStrikesForCurrentTicker({ updateField: false });
  }, 400);
});

tickerInput.addEventListener("change", () => {
  clearTimeout(tickerInputTimer);
  fetchStrikesForCurrentTicker();
});

optionTypeSel.addEventListener("change", () => {
  clearTimeout(tickerInputTimer);
  const t = sanitizeTickerValue();
  if (t) populateStrikes(t, optionTypeSel.value);
  else resetStrikeSelect();
});

document.getElementById("optionForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  clearTimeout(tickerInputTimer);
  const t = sanitizeTickerValue();
  const type = optionTypeSel.value;
  msgEl.textContent = "";
  resultsEl.innerHTML = "";

  if (!t) {
    msgEl.textContent = "Enter a ticker symbol to search.";
    tickerInput.focus();
    return;
  }

  let strike = parseFloat(strikeSelect.value);
  if (!strikeSelect.value || Number.isNaN(strike)) {
    await fetchStrikesForCurrentTicker();
    strike = parseFloat(strikeSelect.value);
    if (!strikeSelect.value || Number.isNaN(strike)) {
      if (!msgEl.textContent) {
        msgEl.textContent = "Please choose a strike price after the list loads.";
      }
      strikeSelect.focus();
      return;
    }
  }

  resultsEl.innerHTML = "Loading…";

  try {
    const rows = await gatherAllRows(t, strike, type);
    if (!rows.length) {
      resultsEl.textContent = "No matching contracts found for that strike across expiries.";
      return;
    }
    let html = "<table><tr><th>Expiry</th><th>Days</th><th>Strike</th><th>Mid</th><th>Premium</th><th>Collateral</th><th>Yield%</th><th>Ann ROI%</th><th>Daily%</th><th>Breakeven</th><th>IV%</th><th>OI</th><th>Vol</th></tr>";
    rows.forEach((r, i) => {
      html += `<tr class="${i===0?'top':''}">
        <td>${r.expiry}</td><td>${r.days}</td><td>${r.strike}</td><td>${r.mid}</td>
        <td>${r.premium}</td><td>${r.collateral}</td><td>${r.yield}</td>
        <td>${r.annROI}</td><td>${r.daily}</td><td>${r.breakeven}</td>
        <td>${r.IV}</td><td>${r.OI}</td><td>${r.Vol}</td>
      </tr>`;
    });
    html += "</table>";
    resultsEl.innerHTML = html;
  } catch (err) {
    msgEl.textContent = "Error: " + err.message;
    resultsEl.innerHTML = "";
  }
});
</script>
</body>
</html>
